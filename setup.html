function generateFairTournament() {
    players = Array.from(document.querySelectorAll('#playerList input')).map(i => i.value);
    const numCourts = parseInt(document.getElementById('cCount').value);
    const mTime = parseInt(document.getElementById('matchTime').value);
    const warmup = parseInt(document.getElementById('warmup').value);
    const start = document.getElementById('startTime').value;
    const totalMin = parseInt(document.getElementById('totalHours').value) * 60;
    const numRounds = Math.floor((totalMin - warmup) / mTime);

    let [sH, sM] = start.split(':').map(Number);
    let schedule = [];
    
    // Tracking für Fairness & Abwechslung
    let playCount = new Array(players.length).fill(0);
    let partnerMatrix = Array.from({ length: players.length }, () => new Array(players.length).fill(0));
    let opponentMatrix = Array.from({ length: players.length }, () => new Array(players.length).fill(0));

    for(let r=1; r<=numRounds; r++) {
        let totalMinCur = sH * 60 + sM + warmup + (r-1)*mTime;
        totalMinCur = Math.round(totalMinCur / 5) * 5;
        let rTime = `${String(Math.floor(totalMinCur/60)%24).padStart(2,'0')}:${String(totalMinCur%60).padStart(2,'0')}`;
        
        let round = { id: r, time: rTime, pause: [], matches: [] };
        
        // 1. Wer ist dran? (Priorität auf Spieler mit wenigsten Einsätzen)
        let pool = [...Array(players.length).keys()].sort((a, b) => {
            if (playCount[a] !== playCount[b]) return playCount[a] - playCount[b];
            return Math.random() - 0.5;
        });

        // 2. Aktive Spieler für diese Runde (4 pro Platz)
        let activeIndices = pool.slice(0, numCourts * 4);
        let bench = pool.slice(numCourts * 4);
        round.pause = bench;

        // 3. Paarungen innerhalb der Aktiven optimieren
        let remaining = [...activeIndices].sort(() => Math.random() - 0.5);
        
        for(let c=1; c<=numCourts; c++) {
            if(remaining.length >= 4) {
                // Wir nehmen den ersten Spieler und suchen den bestmöglichen Partner
                let p1 = remaining.shift();
                remaining.sort((a, b) => partnerMatrix[p1][a] - partnerMatrix[p1][b] || Math.random() - 0.5);
                let p2 = remaining.shift();
                
                // Wir suchen das bestmögliche Gegner-Team
                // Hier versuchen wir Gegner zu finden, gegen die p1 und p2 noch nicht oft gespielt haben
                remaining.sort((a, b) => (opponentMatrix[p1][a] + opponentMatrix[p2][a]) - (opponentMatrix[p1][b] + opponentMatrix[p2][b]) || Math.random() - 0.5);
                let p3 = remaining.shift();
                let p4 = remaining.shift();

                // Stats aktualisieren
                [p1, p2, p3, p4].forEach(idx => playCount[idx]++);
                partnerMatrix[p1][p2]++; partnerMatrix[p2][p1]++;
                partnerMatrix[p3][p4]++; partnerMatrix[p4][p3]++;
                
                [p1, p2].forEach(p => {
                    opponentMatrix[p][p3]++; opponentMatrix[p][p4]++;
                    opponentMatrix[p3][p]++; opponentMatrix[p4][p]++;
                });

                round.matches.push({ court: c, team1: [p1, p2], team2: [p3, p4], score: ["", ""] });
            }
        }
        schedule.push(round);
    }
    currentSchedule = schedule;
    renderPreview();
}
